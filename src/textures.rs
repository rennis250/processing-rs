use std::ops::DerefMut;

use glium;
use image_ext;

use {Screen, ScreenType};

// not a part of the standard OpenGL specs?...
const GL_TEXTURE_MAX_ANISOTROPY_EXT: u32 = 0x84FE;

impl<'a> Screen<'a> {
    pub fn texture<P, S, C>(
        &mut self,
        img: &image_ext::ImageBuffer<P, C>,
    ) -> (glium::texture::Texture2d, f64, f64)
    where
        P: image_ext::Pixel<Subpixel = S> + 'static,
        S: image_ext::Primitive + 'static + glium::texture::ToClientFormat + glium::texture::PixelValue,
        C: DerefMut<Target = [P::Subpixel]>,
    {
        let wh = img.dimensions();
        // let raw = img.into_raw().clone();
        let image_ext = glium::texture::RawImage2d::from_raw_rgba_reversed(&img, wh);
        let texture = match self.display {
            ScreenType::Window(ref d) => {
                glium::texture::Texture2d::with_format(
                    d,
                    image_ext,
                    glium::texture::UncompressedFloatFormat::F32F32F32F32,
                    glium::texture::MipmapsOption::AutoGeneratedMipmaps,
                ).unwrap()
            }
            ScreenType::Headless(ref d) => {
                glium::texture::Texture2d::with_format(
                    d,
                    image_ext,
                    glium::texture::UncompressedFloatFormat::F32F32F32F32,
                    glium::texture::MipmapsOption::AutoGeneratedMipmaps,
                ).unwrap()
            }
        };

        // maxAniso := []float32{0.0}
        // gl::GetFloatv(GL_TEXTURE_MAX_ANISOTROPY_EXT, &maxAniso[0])
        // gl::TexParameterf(gl::TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, maxAniso[0])
        // this will require some performance testing. it might be too heavy for
        // psychophysics
        // gl::TexParameterf(gl::TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, 16f32);

        (
            texture,
            wh.0 as f64 / self.width as f64,
            wh.1 as f64 / self.height as f64,
        )
    }

    pub fn empty_texture(&self, w: u32, h: u32) -> (glium::texture::Texture2d, f64, f64) {
        let texture = match self.display {
            ScreenType::Window(ref d) => {
                glium::texture::Texture2d::empty_with_format(
                    d,
                    glium::texture::UncompressedFloatFormat::F32F32F32F32,
                    glium::texture::MipmapsOption::AutoGeneratedMipmaps,
                    w,
                    h,
                ).unwrap()
            }
            ScreenType::Headless(ref d) => {
                glium::texture::Texture2d::empty_with_format(
                    d,
                    glium::texture::UncompressedFloatFormat::F32F32F32F32,
                    glium::texture::MipmapsOption::AutoGeneratedMipmaps,
                    w,
                    h,
                ).unwrap()
            }
        };

        (
            texture,
            w as f64 / self.width as f64,
            h as f64 / self.height as f64,
        )
    }

    pub fn texture_from_data<P: glium::texture::PixelValue>(
        &self,
        data: Vec<Vec<P>>,
    ) -> (glium::texture::Texture2d, f64, f64) {
        let h = data.len();
        let w = data[0].len();
        let texture = match self.display {
            ScreenType::Window(ref d) => {
                glium::texture::Texture2d::with_mipmaps(
                    d,
                    data,
                    glium::texture::MipmapsOption::AutoGeneratedMipmaps,
                ).unwrap()
            }
            ScreenType::Headless(ref d) => {
                glium::texture::Texture2d::with_mipmaps(
                    d,
                    data,
                    glium::texture::MipmapsOption::AutoGeneratedMipmaps,
                ).unwrap()
            }
        };


        (
            texture,
            w as f64 / self.width as f64,
            h as f64 / self.height as f64,
        )
    }

    pub fn texture_array<T: Clone + 'a + glium::texture::PixelValue>(&mut self, images: Vec<glium::texture::RawImage2d<T>>) -> glium::texture::Texture2dArray {
        match self.display {
            ScreenType::Window(ref d) => {
                glium::texture::Texture2dArray::with_format(d,
                    images,
                    glium::texture::UncompressedFloatFormat::F32F32F32F32,
                    glium::texture::MipmapsOption::AutoGeneratedMipmaps).unwrap()
            }
            ScreenType::Headless(ref d) => {
                glium::texture::Texture2dArray::with_format(d,
                    images,
                    glium::texture::UncompressedFloatFormat::F32F32F32F32,
                    glium::texture::MipmapsOption::AutoGeneratedMipmaps).unwrap()
            }
        }
    }

    // pub fn pixel_buffer(&self, capacity: usize) -> glium::texture::PixelBuffer {
    //     match self.display {
    //         ScreenType::Window(ref d) => {
    //             glium::texture::PixelBuffer::new_empty(d, capacity)
    //         }
    //         ScreenType::Headless(ref d) => {
    //             glium::texture::PixelBuffer::new_empty(d, capacity)
    //         }
    //     }
    // }

    pub fn textureWrap(&mut self, wrap: &str) {
        if wrap == "CLAMP" {
            self.wrap = glium::uniforms::SamplerWrapFunction::Clamp;
        } else if wrap == "REPEAT" {
            self.wrap = glium::uniforms::SamplerWrapFunction::Repeat;
        }
    }
}

// pub fn del_textures(texs: &[u32]) {
// unsafe {
// gl::DeleteTextures(texs.len() as i32, mem::transmute(&texs[0]));
// }
// }
